type Query {
  allLevels: [AccountLevel!]!
  accountDetailsByUserPhone(phone: Phone!): Account!
  accountDetailsByUsername(username: Username!): Account!
  transactionById(id: ID!): Transaction
  transactionsByHash(hash: PaymentHash!): [Transaction]
  lightningInvoice(hash: PaymentHash!): LightningInvoice!
  lightningPayment(hash: PaymentHash!): LightningPayment!
}

enum AccountLevel {
  ONE
  TWO
}

type Account {
  id: ID!
  username: Username
  level: AccountLevel!
  status: AccountStatus!
  title: String
  owner: User!
  coordinates: Coordinates
  createdAt: Timestamp!
}

"""
Unique identifier of a user
"""
scalar Username

enum AccountStatus {
  LOCKED
  ACTIVE
}

type User {
  id: ID!
  phone: Phone!
  language: Language!
  defaultAccount: Account!
  createdAt: Timestamp!
}

"""
Phone number which includes country code
"""
scalar Phone

scalar Language

"""
Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch)
"""
scalar Timestamp

type Coordinates {
  longitude: Float!
  latitude: Float!
}

enum ExchangeCurrencyUnit {
  BTCSAT
  USDCENT
}

union InitiationVia = InitiationViaIntraLedger | InitiationViaLn | InitiationViaOnChain

type InitiationViaIntraLedger {
  counterPartyUsername: Username
  counterPartyWalletId: WalletId
}

"""
Unique identifier of a user
"""
scalar WalletId

type InitiationViaLn {
  paymentHash: PaymentHash!
}

type InitiationViaOnChain {
  address: OnChainAddress!
}

type InputError implements Error {
  code: InputErrorCode!
  message: String!
  path: [String]
}

enum InputErrorCode {
  INVALID_INPUT
  VALUE_NOT_ALLOWED
  VALUE_TOO_LONG
  VALUE_TOO_SHORT
}

scalar Language

type LightningInvoice {
  confirmedAt: Timestamp
  createdAt: Timestamp!
  description: String!
  expiresAt: Timestamp
  isSettled: Boolean!
  received: SatAmount!
  request: LnPaymentRequest
  secret: LnPaymentSecret!
}

type LightningPayment {
  amount: SatAmount
  confirmedAt: Timestamp
  createdAt: Timestamp
  destination: LnPubkey
  request: LnPaymentRequest
  roundedUpFee: SatAmount
  secret: LnPaymentSecret
  status: LnPaymentStatus
}

"""
BOLT11 lightning invoice payment request with the amount included
"""
scalar LnPaymentRequest

scalar LnPaymentSecret

enum LnPaymentStatus {
  FAILED
  PENDING
  SETTLED
}

scalar LnPubkey

"""
Text field in a lightning payment transaction
"""
scalar Memo

type LightningInvoice {
  createdAt: Timestamp!
  confirmedAt: Timestamp
  description: String!
  expiresAt: Timestamp
  isSettled: Boolean!
  received: SatAmount!
  request: LnPaymentRequest
  secret: LnPaymentSecret!
}

"""
(Positive) Satoshi amount (i.g. quiz earning)
"""
scalar SatAmount

union SettlementVia = SettlementViaIntraLedger | SettlementViaLn | SettlementViaOnChain

type SettlementViaIntraLedger {
  """
  Settlement destination: Could be null if the payee does not have a username
  """
  counterPartyUsername: Username
  counterPartyWalletId: WalletId
}

type SettlementViaLn {
  paymentSecret: LnPaymentSecret
}

type Mutation {
  userRequestAuthCode(input: UserRequestAuthCodeInput!): SuccessPayload!
  userLogin(input: UserLoginInput!): AuthTokenPayload!
  accountUpdateLevel(input: AccountUpdateLevelInput!): AccountDetailPayload!
  accountUpdateStatus(input: UserUpdateStatusInput!): AccountDetailPayload!
  businessUpdateMapInfo(input: BusinessUpdateMapInfoInput!): AccountDetailPayload!
}

"""
An amount (of a currency) that can be negative (i.g. in a transaction)
"""
scalar SignedAmount

type SuccessPayload {
  errors: [Error!]!
  success: Boolean
}

interface Error {
  message: String!
  path: [String]
}

input UserRequestAuthCodeInput {
  phone: Phone!
}

"""
Give details about an individual transaction.
Galoy have a smart routing system which is automatically
settling intraledger when both the payer and payee use the same wallet
therefore it's possible the transactions is being initiated onchain
or with lightning but settled intraledger.
"""
type Transaction {
  createdAt: Timestamp!
  direction: TxDirection!
  id: ID!

  """
  From which protocol the payment has been initiated.
  """
  initiationVia: InitiationVia!
  memo: Memo

  """
  Amount of sats paid by the user.
  """
  settlementAmount: SatAmount!
  settlementFee: SatAmount!

  """
  Price in USDCENT/SATS at time of settlement.
  """
  settlementPrice: Price!

  """
  To which protocol the payment has settled on.
  """
  settlementVia: SettlementVia!
  status: TxStatus!
}

"""
A connection to a list of items.
"""
type TransactionConnection {
  """
  A list of edges.
  """
  edges: [TransactionEdge]

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
}

"""
An edge in a connection.
"""
type TransactionEdge {
  """
  A cursor for use in pagination
  """
  cursor: String!

  """
  The item at the end of the edge
  """
  node: Transaction
}

enum TxDirection {
  RECEIVE
  SEND
}

enum TxStatus {
  FAILURE
  PENDING
  SUCCESS
}

type User {
  coordinates: Coordinates
  createdAt: Timestamp!
  id: ID!
  language: Language!
  level: AccountLevel
  phone: Phone!
  status: AccountStatus
  title: String
  username: Username
}

type AccountDetailPayload {
  errors: [Error!]!
  accountDetails: Account
}

input AccountUpdateLevelInput {
  uid: ID!
  level: AccountLevel!
  uid: ID!
}

input UserUpdateStatusInput {
  status: AccountStatus!
  uid: ID!
}

"""
Unique identifier of a user
"""
scalar Username

interface Wallet {
  balance: SignedAmount!
  id: ID!
  transactions(
    """
    Returns the items in the list that come after the specified cursor.
    """
    after: String

    """
    Returns the items in the list that come before the specified cursor.
    """
    before: String

    """
    Returns the first n items from the list.
    """
    first: Int

    """
    Returns the last n items from the list.
    """
    last: Int
  ): TransactionConnection
  walletCurrency: WalletCurrency!
}

enum WalletCurrency {
  BTC
}

"""
Unique identifier of a user
"""
scalar WalletId
